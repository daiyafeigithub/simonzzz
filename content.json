{"meta":{"title":"风","subtitle":"","description":"用一种很新的方式去思考世界","author":"Simon","url":"https://daiyafeigithub.github.io/simonzzz","root":"/simonzzz/"},"pages":[{"title":"about","date":"2025-04-22T14:56:14.397Z","updated":"2025-04-22T14:56:14.397Z","comments":true,"path":"about/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/about/index.html","excerpt":"","text":""},{"title":"experience/study","date":"2025-04-17T06:32:33.000Z","updated":"2025-04-17T06:32:33.000Z","comments":true,"path":"experience-fun/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/experience-fun/index.html","excerpt":"","text":""},{"title":"分类","date":"2025-04-22T14:56:14.397Z","updated":"2025-04-22T14:56:14.397Z","comments":true,"path":"categories/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/index.html","excerpt":"","text":""},{"title":"experience/projects","date":"2025-04-17T06:32:29.000Z","updated":"2025-04-17T06:32:29.000Z","comments":true,"path":"experience-projects/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/experience-projects/index.html","excerpt":"","text":""},{"title":"experience/work","date":"2025-04-17T06:32:26.000Z","updated":"2025-04-17T06:32:26.000Z","comments":true,"path":"experience-work/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/experience-work/index.html","excerpt":"","text":""},{"title":"friends","date":"2025-04-22T14:56:14.397Z","updated":"2025-04-22T14:56:14.397Z","comments":true,"path":"friends/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-04-22T14:56:14.399Z","updated":"2025-04-22T14:56:14.399Z","comments":true,"path":"tags/index.html","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RabbitMQ","slug":"skills/point/rabbitmq","date":"2025-04-22T14:54:22.000Z","updated":"2025-04-22T14:54:22.000Z","comments":true,"path":"2025/04/22/skills/point/rabbitmq/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/22/skills/point/rabbitmq/","excerpt":"","text":"一、RabbitMQ 核心概念与架构RabbitMQ 是基于 AMQP 0-9-1 协议的消息中间件，其核心设计目标是实现高可靠、可扩展的异步通信。以下是关键组件的详细说明： AMQP 协议： 消息模型：生产者（Producer）将消息发送到交换机（Exchange），交换机根据路由规则（Routing Key）将消息分发到队列（Queue），消费者（Consumer）从队列中消费消息。 协议特性：支持消息确认（Ack）、持久化、事务等机制，确保消息可靠传输。 核心组件： Virtual Host：逻辑隔离单元，允许在同一 RabbitMQ 实例中创建多个虚拟环境。 Connection &amp; Channel： Connection：TCP 连接，资源消耗较大。 Channel：轻量级的虚拟连接，复用 Connection，减少系统开销。 Exchange 类型： Direct：精确匹配 Routing Key。 Fanout：广播消息到所有绑定队列。 Topic：支持通配符（* 匹配一个单词，# 匹配零个或多个单词）。 Headers：基于消息头属性匹配（较少使用）。 二、消息传递模式与 Java 示例1. 发布&#x2F;订阅模式（Pub&#x2F;Sub） 场景：日志系统向所有订阅者广播消息。 代码示例：123456789101112131415161718192021222324252627282930313233343536// 生产者public class PubSubProducer &#123; private static final String EXCHANGE_NAME = &quot;pubsub_exchange&quot;; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) &#123; channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); String message = &quot;Broadcast message!&quot;; channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes()); System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;); &#125; &#125;&#125;// 消费者public class PubSubConsumer &#123; private static final String EXCHANGE_NAME = &quot;pubsub_exchange&quot;; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;); String queueName = channel.queueDeclare().getQueue(); channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;); DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123; String message = new String(delivery.getBody(), &quot;UTF-8&quot;); System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;); &#125;; channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;&#125;); &#125;&#125; 2. RPC 模式（Remote Procedure Call） 场景：客户端发起请求，服务端处理后返回结果。 代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// RPC 客户端public class RPCClient &#123; private final Channel channel; private final String replyQueue; public RPCClient() throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); Connection connection = factory.newConnection(); channel = connection.createChannel(); replyQueue = channel.queueDeclare().getQueue(); &#125; public String call(String message) throws Exception &#123; final String corrId = UUID.randomUUID().toString(); AMQP.BasicProperties props = new AMQP.BasicProperties.Builder() .correlationId(corrId) .replyTo(replyQueue) .build(); channel.basicPublish(&quot;&quot;, &quot;rpc_queue&quot;, props, message.getBytes()); final BlockingQueue&lt;String&gt; response = new ArrayBlockingQueue&lt;&gt;(1); DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123; if (delivery.getProperties().getCorrelationId().equals(corrId)) &#123; response.offer(new String(delivery.getBody(), &quot;UTF-8&quot;)); &#125; &#125;; channel.basicConsume(replyQueue, true, deliverCallback, consumerTag -&gt; &#123;&#125;); return response.take(); &#125;&#125;// RPC 服务端public class RPCServer &#123; private static final String RPC_QUEUE_NAME = &quot;rpc_queue&quot;; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) &#123; channel.queueDeclare(RPC_QUEUE_NAME, false, false, false, null); channel.basicQos(1); DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123; String response = &quot;Response to &quot; + new String(delivery.getBody(), &quot;UTF-8&quot;); AMQP.BasicProperties replyProps = new AMQP.BasicProperties.Builder() .correlationId(delivery.getProperties().getCorrelationId()) .build(); channel.basicPublish(&quot;&quot;, delivery.getProperties().getReplyTo(), replyProps, response.getBytes()); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); &#125;; channel.basicConsume(RPC_QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123;&#125;); System.out.println(&quot; [x] Awaiting RPC requests&quot;); &#125; &#125;&#125; 三、高级特性与最佳实践1. 消息持久化 队列持久化：声明队列时设置 durable=true。 消息持久化：发布消息时设置 MessageProperties.PERSISTENT_TEXT_PLAIN。 作用：防止 RabbitMQ 重启后数据丢失。 2. 死信队列（DLQ） 场景：处理未被消费的消息（如消息过期、队列达到最大长度）。 配置：123Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();args.put(&quot;x-dead-letter-exchange&quot;, &quot;dlq_exchange&quot;);channel.queueDeclare(&quot;main_queue&quot;, true, false, false, args); 3. 消息确认与手动应答 手动 Ack：消费者处理完消息后显式发送确认，确保消息不丢失。123channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123;&#125;);// 在 DeliverCallback 中处理完消息后：channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); 4. 集群与高可用 集群模式：将多个 RabbitMQ 节点组成集群，共享队列和消息。 镜像队列：将队列数据同步到多个节点，提升可用性。 四、RabbitMQ 应用场景 流量削峰：应对秒杀、抢红包等高并发场景，通过队列缓冲请求。 异步解耦：解耦订单系统与库存系统，提升系统扩展性。 日志处理：收集分布式系统的日志并分发到分析系统。 数据同步：跨系统数据同步（如订单状态更新）。 五、扩展面试题与答案1. 如何保证消息不丢失？ 答案： 持久化队列和消息。 生产者开启确认机制（Publisher Confirm）。 消费者手动 Ack。 2. 如何处理消息重复消费？ 答案： 使用数据库唯一索引或 Redis 记录已消费消息的唯一 ID。 幂等性设计（如订单支付状态检查）。 3. 什么是消息积压？如何解决？ 答案： 原因：消费者处理速度低于生产速度。 解决方案： 增加消费者实例（水平扩展）。 优化消费者处理逻辑。 临时扩容队列或增加分区。 4. RabbitMQ 与 Kafka 的区别？ 答案： RabbitMQ：低延迟、灵活路由，适合传统消息队列场景。 Kafka：高吞吐、持久化日志，适合大数据流处理。 六、总结RabbitMQ 通过丰富的消息模型和可靠的机制，成为分布式系统中不可或缺的组件。掌握其核心原理、高级特性及实际应用场景，可有效提升系统设计能力。结合 Spring Boot 或 Spring Cloud Stream 可进一步简化集成。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/RabbitMQ/"}]},{"title":"编程题：多线程任务处理","slug":"ask/threadArrange","date":"2025-04-22T14:50:18.000Z","updated":"2025-04-22T14:50:18.000Z","comments":true,"path":"2025/04/22/ask/threadArrange/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/22/ask/threadArrange/","excerpt":"","text":"题目 1: 批量任务处理系统背景描述某电商平台需要定期生成一份销售报告。生成报告的过程分为以下几个步骤： 系统会从数据库中提取一批订单数据（假设共有 5 笔订单）。 每笔订单需要单独计算其销售额和利润（这些计算过程可以并行进行，每笔订单的计算时间随机，范围为 1~3 秒）。 只有当所有订单的计算完成后，系统才能汇总结果并生成最终的销售报告。 具体要求 设计一个程序模拟上述流程，确保所有订单的计算任务都能正确完成。 在所有订单计算完成后，系统应打印一条消息，例如 &quot;Sales report generated successfully!&quot;。 确保程序能够高效运行，避免资源浪费或任务遗漏。 提示 考虑如何让主程序知道所有订单的计算任务已经完成。 需要注意并发环境下的数据一致性问题。 示例输出1234567891011Processing order 1...Processing order 2...Processing order 3...Processing order 4...Processing order 5...Order 1 processed.Order 3 processed.Order 2 processed.Order 5 processed.Order 4 processed.Sales report generated successfully! 题目 2: 多阶段科研实验模拟背景描述某科研团队正在进行一项多阶段的实验研究。实验分为三个阶段，每个阶段都需要多名研究人员协作完成。具体规则如下： 每个研究人员需要依次完成三个阶段的任务（每个阶段的任务耗时随机，范围为 1~2 秒）。 在每个阶段结束时，所有研究人员必须等待其他成员完成当前阶段的任务后，才能进入下一个阶段。 实验结束后，每个研究人员需要提交自己的实验结果。 具体要求 假设有 4 名研究人员参与实验。 模拟整个实验过程，确保所有研究人员按照规则完成任务。 在每个阶段结束时，打印一条消息，例如 &quot;Phase X completed by all researchers&quot;。 实验结束后，每位研究人员打印一条消息，例如 &quot;Researcher-X has submitted the results&quot;。 提示 考虑如何确保研究人员在每个阶段都能同步协作。 注意避免某些研究人员提前进入下一阶段的情况。 示例输出12345678910111213141516171819Researcher 1 is working on Phase 1...Researcher 2 is working on Phase 1...Researcher 3 is working on Phase 1...Researcher 4 is working on Phase 1...Phase 1 completed by all researchersResearcher 1 is working on Phase 2...Researcher 2 is working on Phase 2...Researcher 3 is working on Phase 2...Researcher 4 is working on Phase 2...Phase 2 completed by all researchersResearcher 1 is working on Phase 3...Researcher 2 is working on Phase 3...Researcher 3 is working on Phase 3...Researcher 4 is working on Phase 3...Phase 3 completed by all researchersResearcher 1 has submitted the resultsResearcher 2 has submitted the resultsResearcher 3 has submitted the resultsResearcher 4 has submitted the results 总结这两个题目分别模拟了批量任务处理和多阶段协作的实际业务场景，用户可以根据需求自行选择合适的同步机制（如 CountDownLatch 或 CyclicBarrier）。这种设计方式更贴近实际项目开发中的需求分析与解决方案设计流程，有助于培养用户解决实际问题的能力。","categories":[],"tags":[]},{"title":"面试官问：请问在你的项目中如何使用的线程池","slug":"skills/interview/interview","date":"2025-04-22T14:39:37.000Z","updated":"2025-04-22T14:39:37.000Z","comments":true,"path":"2025/04/22/skills/interview/interview/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/22/skills/interview/interview/","excerpt":"","text":"业务场景：金融交易处理系统场景描述假设我们正在开发一个金融交易处理系统，系统需要处理大量的交易请求，例如股票交易、转账、支付等。每个交易请求需要执行一些短生命周期的任务，例如验证交易信息、计算交易金额、更新账户余额、通知用户等。由于交易请求的数量较大且每个任务的执行时间较短，使用 CachedThreadPool 可以有效地管理和复用线程，减少线程创建和销毁的开销，提高系统的性能和响应速度。 此外，为了确保每个交易请求的线程安全性和数据隔离性，我们将使用 ThreadLocal 来存储每个线程的上下文信息。为了同步多个任务的完成，我们将使用 CountDownLatch 来等待所有任务完成。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194package basic.multipleThread;import java.util.concurrent.*;public class FinancialTransactionSystem &#123; private ExecutorService cachedThreadPool; private CountDownLatch latch; public FinancialTransactionSystem(int numberOfTasks) &#123; // 创建一个可缓存的线程池 this.cachedThreadPool = Executors.newCachedThreadPool(); // 初始化 CountDownLatch this.latch = new CountDownLatch(numberOfTasks); &#125; public void processTransaction(Transaction transaction) &#123; // 提交交易验证任务 cachedThreadPool.submit(new TransactionValidator(transaction, latch)); // 提交交易计算金额任务 cachedThreadPool.submit(new TransactionCalculator(transaction, latch)); // 提交交易更新账户余额任务 cachedThreadPool.submit(new TransactionUpdater(transaction, latch)); // 提交交易通知用户任务 cachedThreadPool.submit(new TransactionNotifier(transaction, latch)); &#125; public void shutdown() &#123; try &#123; // 等待所有任务完成 latch.await(); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;Main thread was interrupted: &quot; + e.getMessage()); &#125; finally &#123; // 关闭线程池 cachedThreadPool.shutdown(); &#125; &#125; public static void main(String[] args) &#123; int numberOfTasks = 40; // 每个交易有4个任务 FinancialTransactionSystem transactionSystem = new FinancialTransactionSystem(numberOfTasks); // 模拟处理多个交易 for (int i = 1; i &lt;= 10; i++) &#123; Transaction transaction = new Transaction(i); transactionSystem.processTransaction(transaction); &#125; // 关闭线程池 transactionSystem.shutdown(); &#125;&#125;// 交易类class Transaction &#123; private int transactionId; public Transaction(int transactionId) &#123; this.transactionId = transactionId; &#125; public int getTransactionId() &#123; return transactionId; &#125;&#125;// 使用 ThreadLocal 存储每个线程的上下文信息class TransactionContext &#123; private static final ThreadLocal&lt;String&gt; transactionId = new ThreadLocal&lt;&gt;(); public static void setTransactionId(String id) &#123; transactionId.set(id); &#125; public static String getTransactionId() &#123; return transactionId.get(); &#125; public static void clearTransactionId() &#123; transactionId.remove(); &#125;&#125;// 交易验证任务class TransactionValidator implements Runnable &#123; private Transaction transaction; private CountDownLatch latch; public TransactionValidator(Transaction transaction, CountDownLatch latch) &#123; this.transaction = transaction; this.latch = latch; &#125; @Override public void run() &#123; try &#123; TransactionContext.setTransactionId(String.valueOf(transaction.getTransactionId())); System.out.println(&quot;TransactionValidator is running for transaction ID: &quot; + TransactionContext.getTransactionId()); // 模拟验证逻辑 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;TransactionValidator was interrupted: &quot; + e.getMessage()); &#125; finally &#123; TransactionContext.clearTransactionId(); latch.countDown(); &#125; &#125;&#125;// 交易计算金额任务class TransactionCalculator implements Runnable &#123; private Transaction transaction; private CountDownLatch latch; public TransactionCalculator(Transaction transaction, CountDownLatch latch) &#123; this.transaction = transaction; this.latch = latch; &#125; @Override public void run() &#123; try &#123; TransactionContext.setTransactionId(String.valueOf(transaction.getTransactionId())); System.out.println(&quot;TransactionCalculator is running for transaction ID: &quot; + TransactionContext.getTransactionId()); // 模拟计算金额逻辑 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;TransactionCalculator was interrupted: &quot; + e.getMessage()); &#125; finally &#123; TransactionContext.clearTransactionId(); latch.countDown(); &#125; &#125;&#125;// 交易更新账户余额任务class TransactionUpdater implements Runnable &#123; private Transaction transaction; private CountDownLatch latch; public TransactionUpdater(Transaction transaction, CountDownLatch latch) &#123; this.transaction = transaction; this.latch = latch; &#125; @Override public void run() &#123; try &#123; TransactionContext.setTransactionId(String.valueOf(transaction.getTransactionId())); System.out.println(&quot;TransactionUpdater is running for transaction ID: &quot; + TransactionContext.getTransactionId()); // 模拟更新账户余额逻辑 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;TransactionUpdater was interrupted: &quot; + e.getMessage()); &#125; finally &#123; TransactionContext.clearTransactionId(); latch.countDown(); &#125; &#125;&#125;// 交易通知用户任务class TransactionNotifier implements Runnable &#123; private Transaction transaction; private CountDownLatch latch; public TransactionNotifier(Transaction transaction, CountDownLatch latch) &#123; this.transaction = transaction; this.latch = latch; &#125; @Override public void run() &#123; try &#123; TransactionContext.setTransactionId(String.valueOf(transaction.getTransactionId())); System.out.println(&quot;TransactionNotifier is running for transaction ID: &quot; + TransactionContext.getTransactionId()); // 模拟通知用户逻辑 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;TransactionNotifier was interrupted: &quot; + e.getMessage()); &#125; finally &#123; TransactionContext.clearTransactionId(); latch.countDown(); &#125; &#125;&#125; 详细过程 创建线程池和 CountDownLatch： 12this.cachedThreadPool = Executors.newCachedThreadPool();this.latch = new CountDownLatch(numberOfTasks); 这行代码创建了一个可缓存的线程池，并初始化了一个 CountDownLatch，用于等待所有任务完成。 提交任务： 1234cachedThreadPool.submit(new TransactionValidator(transaction, latch));cachedThreadPool.submit(new TransactionCalculator(transaction, latch));cachedThreadPool.submit(new TransactionUpdater(transaction, latch));cachedThreadPool.submit(new TransactionNotifier(transaction, latch)); 这里提交了四种不同类型的线程任务：TransactionValidator（验证交易信息）、TransactionCalculator（计算交易金额）、TransactionUpdater（更新账户余额）和 TransactionNotifier（通知用户）。每个任务都实现了 Runnable 接口，并传递了 CountDownLatch 实例。 任务执行： TransactionValidator：验证交易信息。 TransactionCalculator：计算交易金额。 TransactionUpdater：更新账户余额。 TransactionNotifier：通知用户交易状态。 **使用 ThreadLocal**： 12TransactionContext.setTransactionId(String.valueOf(transaction.getTransactionId()));System.out.println(&quot;TransactionValidator is running for transaction ID: &quot; + TransactionContext.getTransactionId()); 在每个任务的 run 方法中，使用 ThreadLocal 存储和获取当前线程的交易 ID，确保每个线程的上下文信息独立且安全。 **使用 CountDownLatch**： 1latch.countDown(); 在每个任务的 finally 块中调用 latch.countDown()，表示一个任务已完成。在 main 方法中调用 latch.await()，等待所有任务完成。 关闭线程池： 1cachedThreadPool.shutdown(); 在 finally 块中调用 shutdown() 方法，确保线程池在任务完成后被正确关闭，释放资源。 总结通过上述示例，展示了如何在金融交易处理系统中使用 CachedThreadPool 来处理大量短生命周期的任务，并结合 ThreadLocal 和 CountDownLatch 来确保线程安全性和任务同步。具体优化点包括： 线程池管理：使用 CachedThreadPool 管理线程，减少线程创建和销毁的开销。 线程安全：使用 ThreadLocal 存储每个线程的上下文信息，确保数据隔离。 任务同步：使用 CountDownLatch 等待所有任务完成，确保主线程在所有任务完成后才继续执行。 这种设计有助于确保金融系统的稳定性和高效性，特别是在高并发的情况下。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程池","slug":"线程池","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"利用大模型实现公司业务的自动化","slug":"AI/howtomakeayewuxian","date":"2025-04-20T14:43:00.000Z","updated":"2025-04-20T14:43:00.000Z","comments":true,"path":"2025/04/20/AI/howtomakeayewuxian/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/20/AI/howtomakeayewuxian/","excerpt":"","text":"一、技术栈选择1. 基础技术框架 大模型平台： 开源模型：LLaMA、Falcon、Stable Diffusion（根据业务类型选择）。 闭源模型：阿里云通义千问、百度文心一言、OpenAI GPT 系列（通过 API 调用）。 开发工具： 模型训练：Hugging Face Transformers、PyTorch、TensorFlow。 部署工具：FastAPI（API 服务）、Docker（容器化）、Kubernetes（集群管理）。 低代码平台：阿里云百炼、百度AI Studio（适合快速开发）。 2. 数据相关技术 数据预处理：Pandas（数据清洗）、NLTK&#x2F;Spacy（文本处理）、OpenCV（图像处理）。 数据标注工具：Label Studio、CVAT（用于标注训练数据）。 数据存储：MySQL&#x2F;MongoDB（结构化数据）、Elasticsearch（日志&#x2F;非结构化数据）。 3. 模型优化技术 微调（Fine-tuning）：LoRA、P-Tuning、全量微调。 模型压缩：量化（8-bit&#x2F;4-bit）、剪枝、蒸馏（Distillation）。 推理加速：ONNX Runtime、TensorRT、vLLM。 二、训练公司业务模型的步骤1. 明确业务场景 需求分析：确定需要替换人工的具体环节（如客服对话、数据录入、报告生成、图像识别等）。 任务类型： 文本生成：如自动生成邮件、报告、代码。 分类&#x2F;识别：如客户意图识别、票据分类。 对话理解：如智能客服、语音助手。 多模态任务：如图像描述生成、视频内容分析。 2. 数据准备 数据收集： 从公司内部系统（如 CRM、ERP）导出历史数据。 收集人工操作的标注数据（如客服对话记录、标注过的图片）。 数据清洗： 去除噪声（重复、错误、无关数据）。 统一格式（如时间戳、文本编码）。 数据标注： 对无标签数据进行人工标注（如分类标签、实体标注）。 使用半自动标注工具（如主动学习）减少人工成本。 3. 模型选择与训练 预训练模型选择： 文本任务：Qwen、GPT-3.5、Llama-2。 图像任务：Stable Diffusion、ResNet。 多模态任务：CLIP、OFA。 模型微调： 全量微调：使用公司数据对模型进行全量参数更新（资源消耗大）。 高效微调：使用 LoRA 或 P-Tuning（仅训练部分参数，节省资源）。 示例代码（Hugging Face）：123456from transformers import AutoModelForSequenceClassification, Trainer, TrainingArgumentsmodel = AutoModelForSequenceClassification.from_pretrained(&quot;bert-base-uncased&quot;)training_args = TrainingArguments(output_dir=&quot;./results&quot;, per_device_train_batch_size=16)trainer = Trainer(model=model, args=training_args, train_dataset=train_dataset)trainer.train() 4. 模型评估与优化 评估指标： 文本生成：BLEU、ROUGE、人工评分。 分类任务：准确率、F1 Score。 时延与吞吐量：TPS（每秒处理事务数）、响应时间。 优化方法： 模型压缩：使用量化（如 bitsandbytes 库）减少模型体积。 缓存机制：对高频查询缓存结果（如 Redis）。 并行推理：使用多 GPU 或分布式推理（如 vLLM）。 三、模型部署与业务集成1. 部署方式 API 服务： 使用 FastAPI 或 Flask 封装模型为 RESTful API。 示例代码（FastAPI）：123456789from fastapi import FastAPIfrom transformers import pipelineapp = FastAPI()model = pipeline(&quot;text-generation&quot;, model=&quot;your-finetuned-model&quot;)@app.post(&quot;/generate&quot;)def generate_text(prompt: str): return model(prompt) 私有化部署： 使用 Docker 容器化部署，结合 Kubernetes 管理集群。 部署到本地服务器或私有云（如阿里云专有云）。 2. 与业务系统集成 触发方式： 实时调用：通过 API 直接与业务系统（如 CRM、ERP）对接。 批量处理：定时任务（如 Airflow）调用模型处理批量数据。 日志与监控： 使用 Prometheus + Grafana 监控模型性能。 记录请求日志，用于后续分析与优化。 四、替换人工的关键挑战与解决方案1. 数据安全与隐私 挑战：公司数据可能包含敏感信息（如客户资料、财务数据）。 解决方案： 数据脱敏：对敏感字段（如身份证号、电话号码）进行掩码处理。 私有化部署：模型和数据均部署在公司内网，避免外传。 2. 模型鲁棒性 挑战：模型可能在长尾场景（如罕见问题）表现不佳。 解决方案： 增加兜底逻辑：对模型无法处理的请求，自动转人工或返回默认答案。 持续学习：定期用新数据重新训练模型。 3. 成本控制 挑战：大模型推理成本高（尤其是闭源模型 API）。 解决方案： 使用轻量级模型（如 DistilBERT）。 按需调用：仅对关键任务调用大模型，其他任务使用规则引擎或小模型。 五、成功案例参考 智能客服： 场景：替换人工客服，自动回答用户问题。 技术：使用 Qwen 或 GPT-3.5 微调，结合对话历史和知识库。 效果：响应时间缩短至秒级，人工替代率提升 70%。 自动化报告生成： 场景：根据销售数据自动生成日报、周报。 技术：使用 T5 或 BART 模型，输入结构化数据输出自然语言文本。 效果：报告生成时间从小时级缩短至分钟级。 图像质检： 场景：工厂流水线产品缺陷检测。 技术：使用 YOLOv8 或 Faster R-CNN 模型，结合少量标注数据微调。 效果：检测准确率提升至 98%，人工复检率降低 90%。 六、总结 技术路径：数据准备 → 模型微调 → 部署为 API → 与业务系统集成 → 持续优化。 关键点： 优先使用开源模型+微调，而非从头训练。 私有化部署保障数据安全。 通过 A&#x2F;B 测试逐步替换人工，避免业务风险。 如果需要更具体的方案（如代码实现、部署细节），可以进一步说明业务场景！","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/AI/"},{"name":"Python","slug":"Python","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Python/"}]},{"title":"云南旅游攻略","slug":"havefun/云南旅游攻略","date":"2025-04-20T14:43:00.000Z","updated":"2025-04-20T14:43:00.000Z","comments":true,"path":"2025/04/20/havefun/云南旅游攻略/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/20/havefun/%E4%BA%91%E5%8D%97%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/","excerpt":"","text":"第一天：城市人文与紫色浪漫上午：蓝花楹大道（教场中路） 亮点：正值蓝花楹盛花期，教场中路约2公里的紫色花廊如瀑布倾泻，是昆明四月最浪漫的景观。 拍摄建议：清晨7点前到达，避开人潮，利用逆光拍摄花瓣的透明质感；可乘坐赏花专线巴士（25元&#x2F;人）俯瞰全景。 周边活动：沿途涂鸦墙和特色市集可逛，推荐尝试蓝花楹主题雪糕。 中午：昆明老街 &amp; 文林街 美食推荐： 过桥米线：老字号“建新园”或“福华园”，体验滚汤现烫的仪式感。 小吃：官渡粑粑（眼镜粑粑店）、小锅米线（文林街小摊）。 文化体验：探访“东方书店”（1926年创办），二楼可边喝咖啡边赏街景。 下午：翠湖公园 &amp; 云南陆军讲武堂 翠湖公园：漫步湖心亭、九曲桥，感受春城慢生活；若天气晴好，可偶遇零星的晚归海鸥。 陆军讲武堂：免费参观黄墙红窗的民国建筑，整点有换岗仪式表演，适合拍摄复古风格照片。 傍晚：滇池海埂大坝 活动：骑行或散步，欣赏滇池落日余晖；若时间充裕，可乘缆车横跨滇池至西山俯瞰全景。 晚上：南屏步行街夜市 推荐：傣味舂鸡脚、昭通小肉串、烤乳扇，搭配木瓜水解腻。 夜景观赏：金马碧鸡坊灯光璀璨，适合打卡拍照。 第二天：自然风光与花海盛宴上午：西山森林公园 &amp; 龙门石窟 玩法： 缆车体验：乘滇池索道横跨湖面，俯瞰滇池与市区全景。 登山路线：龙门景区徒步（约2小时），登顶俯瞰“睡美人”山与滇池相映成趣。 美食：山脚茶马花街品尝烤乳扇、稀豆粉。 中午：云南民族村 特色：体验傣族泼水节活动（四月正值傣历新年），观看《阿诗玛》实景歌舞，品尝哈尼族长街宴。 下午：斗南花市 &amp; 捞鱼河湿地公园 斗南花市：亚洲最大鲜花交易市场，下午5-6点为卸货高峰期，可低价购入玫瑰、百合等，推荐多肉区和文创手信馆。 捞鱼河湿地：傍晚划透明小船穿行水杉林，欣赏滇池日落，四月底或有余留的郁金香花海。 返程前晚餐：野生菌火锅 推荐餐厅：“滇菌王”或“一朵菌”，必点鸡枞、松茸、牛肝菌，搭配汽锅鸡汤底。 住宿推荐 翠湖周边：如“翠湖宾馆”，步行可达公园、讲武堂，方便感受老城韵味。 南屏街商圈：如“昆明中心皇冠假日酒店”，毗邻夜市，购物餐饮便利。 注意事项 防晒与保暖：昆明紫外线强，需备防晒霜、墨镜；早晚温差大，建议携带薄外套。 交通：地铁4号线直达斗南花市（金桂街站），市区景点建议打车或共享单车。 花期提示：蓝花楹最佳拍摄时间为清晨或傍晚，教场中路周末人流密集，建议早到。 乘车路线第一天：城市人文与紫色浪漫 上午（4月26日） 住宿出发 → 教场中路蓝花楹大道 交通：地铁3号线至「教场中路站」步行5分钟，或打车直达。 活动：拍摄蓝花楹花海（建议7:00前到达，避开人流），品尝蓝花楹雪糕。 教场中路 → 昆明老街 &amp; 文林街 交通：步行或共享单车（约1.5公里）。 活动：老街午餐（建新园过桥米线），文林街咖啡馆打卡，探访东方书店。下午 文林街 → 翠湖公园 交通：步行（约10分钟）。 活动：翠湖漫步，喂海鸥（若遇晚归海鸥群），陆军讲武堂参观（注意换岗仪式时间）。 翠湖公园 → 滇池海埂大坝 交通：地铁5号线至「滇池站」转公交K31路，或打车（约20分钟）。 活动：骑行环湖，欣赏落日，可选缆车至西山。傍晚 滇池 → 南屏步行街夜市 交通：地铁5号线转1号线至「东风广场站」步行。 活动：品尝夜市小吃（傣味鸡脚、烤乳扇），打卡金马碧鸡坊夜景。 第二天：自然风光与花海盛宴上午 住宿出发 → 西山森林公园 &amp; 龙门石窟 交通：地铁3号线至「西山公园站」转缆车&#x2F;公交。 活动：乘滇池索道上山，徒步龙门石窟，俯瞰滇池全景。 西山 → 云南民族村 交通：缆车下山后打车（约15分钟）。 活动：体验傣族泼水节（4月活动），观看歌舞表演，品尝长街宴。 下午 民族村 → 斗南花市 交通：地铁4号线至「金桂街站」步行5分钟。 活动：逛亚洲最大花市（下午5点后价格更优惠），购买鲜花和手信。 斗南花市 → 捞鱼河湿地公园 交通：公交K31路或打车（约20分钟）。 活动：划透明小船游水杉林，拍摄日落与滇池倒影，寻找郁金香花海。返程前 捞鱼河湿地 → 野生菌火锅餐厅 交通：打车至市区餐厅（推荐「滇菌王」或「一朵菌」）。 晚餐：品尝新鲜菌火锅，结束行程后返回住宿。 路线图标注说明 交通颜色：地铁（蓝色）· 公交（红色）· 打车&#x2F;缆车（橙色）· 步行&#x2F;骑行（绿色） 关键节点： 住宿：推荐翠湖或南屏街附近，两天可住同一酒店。 时间提醒：蓝花楹清晨拍最佳，斗南花市下午5点后更热闹。 特别提示： 西山缆车需提前购票（节假日可能排队）； 捞鱼河湿地日落约19:30，建议预留1小时拍摄时间。 路线优势 景点串联高效：地铁+公交覆盖主要景点，避免反复折返。 季节适配：突出4月蓝花楹、郁金香花海及傣历新年活动。 灵活调整：若体力有限，可省略西山徒步，优先体验花市和湿地。","categories":[{"name":"旅游","slug":"旅游","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%97%85%E6%B8%B8/"}],"tags":[{"name":"旅游","slug":"旅游","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%97%85%E6%B8%B8/"}],"author":"Simon"},{"title":"高级Java开发必备技能点和复习计划","slug":"skills/interview/plan","date":"2025-04-20T14:43:00.000Z","updated":"2025-04-20T14:43:00.000Z","comments":true,"path":"2025/04/20/skills/interview/plan/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/20/skills/interview/plan/","excerpt":"","text":"一、核心知识点（按重要性排序）1. Java核心 集合框架（HashMap、ConcurrentHashMap、ArrayList、LinkedList、TreeMap、HashSet源码分析） 多线程与并发（线程池、synchronized、volatile、CAS、AQS、ReentrantLock、ReadWriteLock） JVM（内存模型、GC算法、类加载机制、JVM调优、内存泄漏排查） IO&#x2F;NIO（BIO&#x2F;NIO&#x2F;AIO区别、Selector、Buffer、Channel） 反射、注解、动态代理 2. 并发编程 线程池（ThreadPoolExecutor参数、拒绝策略、Callable&#x2F;Future） 并发工具类（CountDownLatch、CyclicBarrier、Semaphore、Exchanger） 原子类（AtomicInteger、AtomicReference） ThreadLocal（内存泄漏问题） 死锁检测与避免 3. JVM 内存结构（堆、栈、方法区、元空间、直接内存） 垃圾回收（GC算法、CMS&#x2F;G1&#x2F;ZGC原理、GC日志分析） 类加载机制（双亲委派、自定义类加载器） JVM参数调优（堆内存分配、GC策略选择） 4. 框架 Spring（IoC、AOP、事务管理、循环依赖、Bean生命周期） Spring Boot（自动配置原理、Starter开发、Actuator） Spring Cloud（服务注册发现、配置中心、熔断器、网关） MyBatis（缓存机制、插件原理、动态SQL） Netty（Reactor模式、ChannelPipeline、ByteBuf） 5. 数据库 SQL优化（索引原理、执行计划、慢查询优化） 事务（ACID、隔离级别、MVCC、分布式事务） 锁机制（行锁、表锁、乐观锁、悲观锁） 分库分表（ShardingSphere、数据迁移、分布式ID） NoSQL（Redis数据结构、持久化、集群、缓存穿透&#x2F;雪崩） 6. 分布式系统 CAP理论、BASE理论 一致性算法（Raft、Paxos） 分布式事务（2PC、3PC、TCC、Saga） 消息队列（Kafka、RocketMQ、RabbitMQ：消息可靠性、顺序性、重复消费） 分布式锁（Redis&#x2F;ZooKeeper实现） 微服务（服务治理、限流、熔断、降级） 7. 设计模式 创建型（单例、工厂、建造者） 结构型（代理、适配器、装饰器） 行为型（观察者、策略、模板方法） 设计原则（SOLID、DRY、KISS） 8. 系统设计 高并发系统（限流、降级、缓存、异步） 高可用系统（集群、负载均衡、灾备） 一致性设计（最终一致性、补偿机制） 经典案例（秒杀系统、短链生成、分布式缓存） 9. 工具与中间件 Redis（数据结构、集群、哨兵、Pipeline） ZooKeeper（选举机制、分布式锁、配置中心） Elasticsearch（倒排索引、分片、查询优化） Nginx（反向代理、负载均衡、动静分离） 10. 算法与数据结构 LeetCode（高频题：链表、树、排序、动态规划） 排序算法（快排、归并、堆排） 复杂度分析（时间&#x2F;空间复杂度） 11. 操作系统与网络 TCP&#x2F;IP（三次握手、四次挥手、滑动窗口） HTTP&#x2F;HTTPS（状态码、Header、HTTP2新特性） 进程与线程（区别、通信方式） 内存管理（虚拟内存、页面置换算法） 二、复习计划（4周冲刺）第1周：Java核心 + 并发编程 Day1-2：集合源码（HashMap、ConcurrentHashMap） Day3-4：线程池、CAS、AQS、ReentrantLock Day5-6：JVM内存模型、GC算法、类加载 Day7：模拟面试题（Java基础） 第2周：框架 + 数据库 Day8-9：Spring IoC&#x2F;AOP、循环依赖、事务 Day10-11：MyBatis缓存、动态SQL Day12-13：SQL优化、索引原理、事务隔离 Day14：模拟面试题（框架+数据库） 第3周：分布式系统 + 系统设计 Day15-16：分布式事务、消息队列、分布式锁 Day17-18：Redis持久化、集群、缓存问题 Day19-20：系统设计案例（秒杀、短链） Day21：模拟面试题（分布式+设计） 第4周：算法 + 综合提升 Day22-24：刷高频算法题（LeetCode中等+困难） Day25-26：操作系统、网络基础 Day27-28：项目复盘（技术难点、优化点） Day29-30：模拟面试（全流程） 三、关键建议 项目深挖：准备2-3个复杂项目，重点描述技术选型、难点、优化方案。 源码阅读：至少精读一个框架源码（如Spring或MyBatis）。 模拟面试：通过LeetCode、牛客网进行模拟，训练表达能力。 高频问题：准备“为什么离开上家公司”、“职业规划”等软技能问题。 四、资源推荐 书籍：《Java并发编程实战》《深入理解JVM》《设计模式之禅》 网站：LeetCode、牛客网、极客时间 工具：Arthas（JVM调试）、JProfiler（性能分析） 如有需要更进之处还请评论区指点！","categories":[],"tags":[],"author":"Simon"},{"title":"怎么在github pages部署自己的hexo项目","slug":"skills/point/howToCreateHexoAtGithubPages","date":"2025-04-20T14:43:00.000Z","updated":"2025-04-20T14:43:00.000Z","comments":true,"path":"2025/04/20/skills/point/howToCreateHexoAtGithubPages/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/20/skills/point/howToCreateHexoAtGithubPages/","excerpt":"","text":"在 GitHub Pages 上部署 Hexo 项目是一个常见的需求，Hexo 是一个基于 Node.js 的静态博客生成器，而 GitHub Pages 是一个免费的静态网站托管服务。以下是详细的步骤，帮助你完成 Hexo 项目的部署。 1. 准备工作确保你已经完成以下准备工作： 安装 Node.js 和 npm。 安装 Git。 创建一个 GitHub 仓库（如果还没有）。 2. 安装 Hexo如果你还没有安装 Hexo，可以通过以下命令安装： 1npm install -g hexo-cli 3. 初始化 Hexo 项目在本地初始化一个 Hexo 项目： 123hexo init my-blogcd my-blognpm install my-blog 是你的项目文件夹名称，可以根据需要修改。 4. 配置 Hexo在 Hexo 项目的根目录下，编辑 _config.yml 文件，设置以下内容： 配置部署信息找到 deploy 部分，修改为以下内容： 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: main repo：你的 GitHub 仓库地址。如果仓库名是 username.github.io，GitHub Pages 会自动部署到根目录。 branch：部署分支，通常为 main 或 gh-pages。 配置 URL 和根目录找到 url 和 root 部分，根据你的仓库名称设置： 如果仓库名是 username.github.io： 12url: https://username.github.ioroot: / 如果仓库名是其他名称（如 my-blog）： 12url: https://username.github.io/my-blogroot: /my-blog/ 5. 安装 Hexo 部署插件Hexo 需要一个插件来支持 Git 部署。安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 6. 生成静态文件并部署在项目根目录下运行以下命令： 123hexo cleanhexo generatehexo deploy hexo clean：清理缓存和旧文件。 hexo generate：生成静态文件到 public 目录。 hexo deploy：将生成的静态文件部署到 GitHub 仓库。 7. 配置 GitHub Pages 打开 GitHub 仓库，进入 Settings -&gt; Pages。 在 Source 部分，选择部署分支（如 main 或 gh-pages）。 确保 Custom domain 为空（除非你使用了自定义域名）。 点击 Save 保存设置。 8. 访问你的 GitHub Pages部署完成后，访问以下 URL 查看你的网站： 如果仓库名是 username.github.io，访问 https://username.github.io。 如果仓库名是其他名称（如 my-blog），访问 https://username.github.io/my-blog。 9. 自动部署（可选）如果你希望每次推送代码时自动部署，可以使用 GitHub Actions。 创建 GitHub Actions 工作流在项目根目录下创建 .github/workflows/deploy.yml 文件，内容如下： 123456789101112131415161718192021222324252627282930313233name: Deploy Hexo to GitHub Pageson: push: branches: [&quot;main&quot;]jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: 18 - name: Install Hexo and dependencies run: | npm install -g hexo-cli npm install - name: Generate static files run: | hexo clean hexo generate - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./public 这个工作流会在每次推送到 main 分支时自动生成静态文件并部署到 gh-pages 分支。 10. 常见问题页面没有样式 检查 _config.yml 中的 url 和 root 配置是否正确。 确保资源文件路径正确，可以通过浏览器开发者工具查看是否有资源加载失败。 部署失败 检查 GitHub 仓库的 Settings -&gt; Pages，确保部署分支正确。 确保 hexo-deployer-git 插件已安装。 自定义域名 如果你使用了自定义域名，在 source 目录下创建 CNAME 文件，内容为你的域名。例如：1example.com 总结通过以上步骤，你可以将 Hexo 项目成功部署到 GitHub Pages。如果需要自动部署，可以使用 GitHub Actions 实现持续集成。如果有任何问题，可以参考 Hexo 和 GitHub Pages 的官方文档，或查看 GitHub 仓库的构建日志。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"如何在vue+springboot项目中使用https","slug":"skills/point/howtousehttps","date":"2025-04-20T14:43:00.000Z","updated":"2025-04-20T14:43:00.000Z","comments":true,"path":"2025/04/20/skills/point/howtousehttps/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/20/skills/point/howtousehttps/","excerpt":"","text":"在 Vue + Spring Boot 项目中使用 HTTPS，需要分别在 Vue 前端和 Spring Boot 后端进行配置。以下是具体步骤： 1. 生成 SSL 证书首先，你需要一个 SSL 证书。可以使用自签名证书进行测试，或从受信任的证书颁发机构（CA）获取正式证书。 自签名证书生成使用 OpenSSL 生成自签名证书： 1openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes 这将生成 key.pem（私钥）和 cert.pem（证书）文件。 2. 配置 Spring Boot 使用 HTTPS将证书放入 Spring Boot 项目将生成的 key.pem 和 cert.pem 文件放入 src/main/resources 目录。 修改 application.properties在 application.properties 中添加以下配置： 1234server.port=8443server.ssl.key-store=classpath:keystore.p12server.ssl.key-store-password=your_passwordserver.ssl.key-password=your_password 将 key.pem 和 cert.pem 转换为 PKCS12 格式： 1openssl pkcs12 -export -in cert.pem -inkey key.pem -out keystore.p12 -name tomcat -CAfile cert.pem -caname root 将生成的 keystore.p12 放入 src/main/resources 目录。 3. 配置 Vue 使用 HTTPS修改 Vue 开发服务器配置在 vue.config.js 中配置开发服务器使用 HTTPS： 12345678910111213141516171819const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);module.exports = &#123; devServer: &#123; port: 8080, https: &#123; key: fs.readFileSync(path.resolve(__dirname, &#x27;key.pem&#x27;)), cert: fs.readFileSync(path.resolve(__dirname, &#x27;cert.pem&#x27;)), &#125;, proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;https://localhost:8443&#x27;, secure: false, changeOrigin: true, &#125;, &#125;, &#125;,&#125;; 将 key.pem 和 cert.pem 放入 Vue 项目根目录。 4. 部署配置前端部署将 Vue 项目打包并部署到支持 HTTPS 的服务器（如 Nginx 或 Apache）。 后端部署将 Spring Boot 项目打包为 JAR 或 WAR 文件，并部署到支持 HTTPS 的服务器。 5. 测试启动 Spring Boot 和 Vue 项目，分别通过 https://localhost:8443 和 https://localhost:8080 访问，确保 HTTPS 正常工作。 6. 其他注意事项 证书有效期：自签名证书仅用于测试，生产环境应使用受信任的 CA 证书。 混合内容：确保前端资源（如 JS、CSS）通过 HTTPS 加载，避免混合内容问题。 CORS：如果前后端分离部署，配置正确的 CORS 策略。 通过这些步骤，你的 Vue + Spring Boot 项目将能够使用 HTTPS 进行安全通信。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%95%99%E7%A8%8B/"},{"name":"deepseek","slug":"deepseek","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/deepseek/"}]},{"title":"中级软考证书20天冲刺计划","slug":"skills/point/中级软考证书20天冲刺计划","date":"2025-04-20T14:43:00.000Z","updated":"2025-04-20T14:43:00.000Z","comments":true,"path":"2025/04/20/skills/point/中级软考证书20天冲刺计划/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/20/skills/point/%E4%B8%AD%E7%BA%A7%E8%BD%AF%E8%80%83%E8%AF%81%E4%B9%A620%E5%A4%A9%E5%86%B2%E5%88%BA%E8%AE%A1%E5%88%92/","excerpt":"","text":"中级软考（软件水平考试）是中国计算机技术与软件专业技术资格（水平）考试的一部分，通常包括《基础知识》和《应用技术》两部分。距离考试还有20天的时间，突击复习需要高效且有计划地进行。以下是一个详细的复习路线规划，涵盖知识点梳理、时间安排和备考建议。 一、复习目标 基础知识：掌握考试大纲中的核心知识点，熟悉选择题的常见考点。 应用技术：理解案例分析题的解题思路，能够快速定位问题并给出解决方案。 模拟练习：通过真题和模拟题训练答题速度和准确率。 二、复习规划（20天）第一阶段：基础巩固（第1-7天）目标：全面梳理考试大纲中的知识点，夯实基础。 基础知识部分 重点内容： 计算机系统知识 计算机组成原理（CPU、内存、I&#x2F;O设备等） 操作系统基础（进程管理、存储管理、文件系统） 数据库基础（关系模型、SQL语言、事务管理） 网络基础 网络协议（TCP&#x2F;IP、HTTP、DNS等） 网络架构（OSI七层模型、IP地址分类） 软件工程 软件生命周期（需求分析、设计、编码、测试、维护） 常见开发模型（瀑布模型、敏捷开发） 信息安全 加密算法（对称加密、非对称加密） 安全威胁与防护措施 法律法规与标准化 知识产权保护 标准化基础知识（ISO、GB&#x2F;T） 复习方法： 按照考试大纲逐条学习，使用教材或在线课程辅助理解。 制作知识点卡片，方便随时翻阅记忆。 每天完成一部分内容后，做对应章节的选择题练习。 应用技术部分 重点内容： 案例分析 需求分析（如何识别用户需求） 系统设计（模块划分、接口设计） 测试方法（黑盒测试、白盒测试） 项目管理 项目范围管理 进度管理（关键路径法、甘特图） 成本管理（挣值分析） 复习方法： 学习经典案例，总结常见问题及解题思路。 针对每种题型（如需求变更、进度延误等），整理出模板化答案。 第二阶段：强化训练（第8-15天）目标：通过真题和模拟题提升答题能力，查漏补缺。 基础知识部分 每天完成一套真题或模拟题的选择题部分。 分析错题，标记薄弱知识点，针对性复习。 对高频考点（如数据库SQL语句、网络协议等）进行专项练习。 应用技术部分 每天完成2-3道案例分析题，严格按照考试时间要求完成。 总结答题模板，例如： 需求变更问题：“首先确认变更的必要性，其次评估变更的影响，最后制定实施计划。” 进度延误问题：“分析延误原因，调整关键路径活动，重新分配资源。” 时间分配 每天上午：基础知识复习+练习 下午：应用技术案例分析 晚上：错题回顾与总结 第三阶段：冲刺模拟（第16-20天）目标：模拟真实考试环境，提升应试能力。 整卷模拟 每天完成一套完整的真题或模拟题，严格按照考试时间（基础知识150分钟，应用技术150分钟）进行。 模拟后认真分析试卷，总结经验教训。 重点突破 针对前两个阶段发现的薄弱环节，集中精力复习。 对高频考点进行最后的记忆强化，例如： SQL查询语句 关键路径计算公式 信息安全加密算法 心理调整 保持良好的作息，避免熬夜。 调整心态，树立信心，相信自己的努力会有回报。 三、详细知识点清单基础知识 计算机系统知识 CPU结构与功能 内存层次结构（Cache、RAM、ROM） 输入输出设备工作原理 操作系统 进程与线程的区别 死锁的产生条件与预防 文件系统结构 数据库 关系模型的基本概念 SQL查询语句（SELECT、INSERT、UPDATE、DELETE） 数据库事务特性（ACID） 网络基础 OSI七层模型与TCP&#x2F;IP四层模型 常见网络协议（HTTP、FTP、SMTP） IP地址分类与子网划分 信息安全 对称加密与非对称加密算法 数字签名与认证机制 常见安全威胁（病毒、木马、DDoS攻击） 应用技术 需求分析 需求获取方法（访谈、问卷调查） 需求文档编写规范 系统设计 模块划分原则 接口设计注意事项 测试方法 黑盒测试与白盒测试的区别 测试用例设计方法 项目管理 项目范围管理工具（WBS） 关键路径法计算 挣值分析公式（PV、EV、AC、CV、SV） 四、备考建议 合理分配时间 每天至少保证6小时的复习时间，分段进行基础知识和应用技术的学习。 善用工具 使用思维导图整理知识点。 下载历年真题和模拟题APP，随时随地刷题。 保持专注 减少干扰，专注于复习内容。 定期休息，避免过度疲劳。 中级软考证书考试虽然难度适中，但涉及的知识点广泛，需要考生在短时间内高效复习。按照上述规划，您可以在20天内完成从基础到强化再到冲刺的全过程复习。坚持每天按计划执行，结合真题练习，相信您一定能够顺利通过考试！","categories":[{"name":"软考","slug":"软考","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E8%BD%AF%E8%80%83/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E8%BD%AF%E8%80%83/"},{"name":"中级软考","slug":"中级软考","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E4%B8%AD%E7%BA%A7%E8%BD%AF%E8%80%83/"}],"author":"Simon"},{"title":"如何利用PC微信客户端实现微信机器人","slug":"AI/wechatrebot","date":"2025-04-15T07:44:17.000Z","updated":"2025-04-15T07:44:17.000Z","comments":true,"path":"2025/04/15/AI/wechatrebot/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/15/AI/wechatrebot/","excerpt":"","text":"微信机器人搭建指南本文将详细介绍如何使用PC微信客户端搭建一个功能强大的微信机器人。通过本教程，您可以实现自动回复、消息转发等实用功能。 1. 环境准备1.1 安装PyCharm首先需要安装Python开发环境PyCharm： 下载地址：PyCharm官方下载 选择Community（社区版）即可满足需求 1.2 获取项目代码我们使用WeChatRobot项目作为基础： GitHub地址：https://github.com/lich0821/WeChatRobot.git 国内镜像（推荐）：https://gitee.com/lch0821/WeChatRobot.git 2. 项目配置2.1 配置Python解释器 打开PyCharm 进入设置（Settings） 选择项目解释器（Project Interpreter） 添加新的Python解释器 2.2 安装依赖包在项目根目录下找到requirements.txt文件，使用以下命令安装依赖： 1pip install -r requirements.txt 3. 下载必要组件3.1 下载WeChatFerry这是实现微信机器人的核心组件： 下载地址：WeChatFerry v0.0.26 3.2 安装指定版本微信重要提示：必须使用指定版本的微信客户端，否则可能无法正常运行： 下载地址：微信3.9.12.17版本 4. 运行机器人 确保所有组件都已正确安装 打开PyCharm 运行项目根目录下的main.py文件 注意事项 请确保使用指定版本的微信客户端 首次运行时可能需要管理员权限 建议在运行前关闭其他微信进程 如遇到问题，可以查看项目文档或提交Issue 后续更新本文将持续更新，添加更多实用功能和问题解决方案。如果您有任何问题或建议，欢迎在评论区留言。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/AI/"},{"name":"Python","slug":"Python","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Python/"}]},{"title":"explain全解析","slug":"skills/mysql/explain","date":"2025-04-13T07:32:21.000Z","updated":"2025-04-13T07:32:21.000Z","comments":true,"path":"2025/04/13/skills/mysql/explain/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/13/skills/mysql/explain/","excerpt":"","text":"EXPLAIN 是 MySQL 中用于分析 SQL 查询执行计划的核心工具。它可以帮助开发者理解 MySQL 如何执行查询（如表连接顺序、索引使用情况、扫描行数等），从而优化查询性能。以下是 EXPLAIN 的详细解析和使用示例。 一、基础语法1EXPLAIN [选项] SQL语句; 例如： 1EXPLAIN SELECT * FROM users WHERE id = 1; 二、输出字段详解EXPLAIN 的输出结果包含以下关键字段，每个字段反映了查询执行计划的细节： 1. id 含义：查询的唯一标识符。 规则： 简单查询（单表）的 id 相同。 复杂查询（如子查询、联合查询）中，每个子查询会生成不同的 id。 id 值越大，优先级越高，越先执行。 2. select_type 含义：查询的类型。 常见值： SIMPLE：简单查询（不包含子查询或 UNION）。 PRIMARY：最外层的查询（包含子查询或 UNION）。 SUBQUERY：子查询中的第一个 SELECT。 DERIVED：派生表（如 FROM 子句中的子查询）。 UNION：UNION 中的第二个或后续 SELECT。 UNION RESULT：UNION 的结果。 3. table 含义：当前操作的表名。 示例：&lt;derived2&gt; 表示一个派生表（临时表）。 4. partitions 含义：涉及的分区（如果表是分区表）。 5. type 含义：访问类型（从最优到最差）： system：表只有一行（系统表）。 const：通过主键或唯一索引匹配一行。 eq_ref：唯一索引扫描（多表连接时）。 ref：非唯一索引扫描。 range：索引范围扫描。 index：全索引扫描（覆盖索引）。 ALL：全表扫描（需优化）。 优化目标：尽量避免 ALL，追求 const、eq_ref、ref。 6. possible_keys 含义：可能应用的索引列表。 7. key 含义：实际使用的索引。 8. key_len 含义：索引使用的字节数。 作用：判断联合索引是否被完全使用。 示例：若索引是 (a, b)，key_len 为 a 的长度，说明只使用了部分索引。 9. ref 含义：索引的哪一列或常量被用于匹配。 示例：const（常量）、func（函数）、某个字段。 10. rows 含义：预估需要扫描的行数。 优化目标：越小越好。 11. filtered 含义：通过条件过滤的行百分比（与 rows 结合估算实际行数）。 12. Extra 含义：额外信息，关键优化提示。 常见值： Using where：使用 WHERE 条件过滤。 Using index：使用覆盖索引（无需回表）。 Using temporary：使用临时表（需优化）。 Using filesort：使用文件排序（需优化）。 Select tables optimized away：查询被优化器直接返回结果（如聚合函数）。 三、示例分析示例 1：全表扫描1EXPLAIN SELECT * FROM employees; 输出： 12345+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | employees | NULL | ALL | NULL | NULL | NULL | NULL | 3000 | 100.00 | NULL |+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+ 分析： type 为 ALL（全表扫描），需添加索引优化。 示例 2：使用索引1EXPLAIN SELECT name FROM employees WHERE id = 1; 输出： 12345+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+| 1 | SIMPLE | employees | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | Using index |+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+ 分析： type 为 const（主键查询），Using index 表示使用了覆盖索引。 示例 3：复杂查询（JOIN）1234EXPLAIN SELECT a.name, b.salary FROM employees a JOIN salaries b ON a.id = b.employee_id WHERE a.department = &#x27;IT&#x27;; 输出： 123456+----+-------------+-------+------------+------+---------------+---------+---------+----------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+---------+---------+----------------+------+----------+-------------+| 1 | SIMPLE | a | NULL | ref | idx_dept | idx_dept| 768 | const | 100 | 100.00 | Using where || 1 | SIMPLE | b | NULL | ref | emp_id | emp_id | 4 | test.a.id | 10 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+---------+---------+----------------+------+----------+-------------+ 分析： employees 表通过 idx_dept 索引筛选出 100 行。 salaries 表通过 emp_id 索引与 employees 表关联。 四、优化建议 避免全表扫描（ALL） 为 WHERE、JOIN、ORDER BY 条件添加合适的索引。 示例：ALTER TABLE employees ADD INDEX idx_dept (department); 减少回表（Using index） 使用覆盖索引（查询字段全部包含在索引中）。 优化临时表和文件排序 减少复杂查询中的 DISTINCT、GROUP BY、ORDER BY。 确保排序字段有索引。 关联查询优化 小表驱动大表。 确保关联字段有索引。 五、常见误区 索引越多越好？错误。过多的索引会降低写入性能，需权衡查询与写入需求。 EXPLAIN 的 rows 是准确的？不准确。它是 MySQL 的预估值，实际行数可能不同。 type &#x3D; range 一定比 ref 差？不一定。范围查询可能更高效，需结合具体场景。 六、进阶用法 分析 UPDATE&#x2F;DELETE 1EXPLAIN UPDATE employees SET salary = 10000 WHERE department = &#x27;IT&#x27;; 查看分区信息 1EXPLAIN PARTITIONS SELECT * FROM partitioned_table; 结合 SHOW WARNINGS 12EXPLAIN EXTENDED SELECT ...;SHOW WARNINGS; 总结通过 EXPLAIN，可以快速定位查询性能瓶颈，优化索引和 SQL 逻辑。建议在开发过程中对复杂查询进行常态化分析，避免生产环境出现慢查询。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/mysql/"}]},{"title":"面试题 2025-04-10 12:42:14","slug":"skills/interview/interview6","date":"2025-04-10T04:42:06.000Z","updated":"2025-04-10T04:42:06.000Z","comments":true,"path":"2025/04/10/skills/interview/interview6/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/10/skills/interview/interview6/","excerpt":"","text":"以下是基于艾梦秋简历内容设计的30分钟模拟面试题，涵盖技术深度、项目经验和综合能力考察： 一、技术基础考察（8分钟） Java核心 你在项目中使用过ConcurrentHashMap，请说明它的线程安全实现原理，与Hashtable有何区别？ 如何通过Java Stream API对一个用户列表进行分组统计（如按城市分组）？请举例代码片段。 JVM与优化 解释JVM内存模型中堆内存的分代机制，Minor GC和Full GC的触发条件是什么？ 在项目中是否遇到过内存泄漏问题？如何通过工具（如MAT）定位和解决？ 数据库与优化 在MySQL中，索引的最左匹配原则是什么？如何通过EXPLAIN分析慢查询？ 分库分表后如何解决跨库查询问题？ShardingSphere的分片策略有哪些？ 二、框架与中间件（10分钟） Spring生态 Spring Boot的自动配置原理是什么？如何自定义一个Starter？ 你在项目中使用Sentinel实现熔断，如何配置一个基于异常比例的熔断策略？ 分布式与微服务 Seata的AT模式如何保证分布式事务一致性？请描述其两阶段提交过程。 RabbitMQ如何保证消息可靠性投递？消息重复消费如何解决？ 缓存与性能 如何设计Redis的缓存穿透解决方案？布隆过滤器的原理和适用场景是什么？ 在项目中如何通过Redis优化高并发查询？是否遇到缓存击穿问题？如何解决？ 三、项目深度追问（10分钟） 福建移动管线资源管理系统 资源拓扑关系算法的核心逻辑是什么？如何实现光缆链路级联查询的秒级响应？ 结合Seata和RabbitMQ解决分布式事务时，消息重试机制的具体实现步骤是什么？ 技术选型与权衡 为什么选择ShardingSphere+ Elasticsearch的组合实现亿级数据查询？是否考虑过其他方案（如ClickHouse）？ 在限流策略中，Sentinel的QPS限流和线程数限流分别适用于什么场景？ 四、综合能力（2分钟） 设计模式与重构 你在项目中用过哪些设计模式？请举例说明工厂模式在Spring中的应用。 如何重构一段重复代码？请描述重构的步骤和注意事项。 学习与协作 最近学习的一项新技术是什么？如何快速掌握并应用到项目中？ 在团队协作中，如何解决技术方案分歧（如同事坚持使用效率低的实现方式）？ 以下是为艾梦秋简历定制的 场景题补充，结合其项目经验和技术栈，模拟真实业务场景考察综合能力： 五、场景设计题（新增）场景1：分布式事务冲突（结合福建移动项目）背景：在资源调度接口中，两个并发请求同时修改同一条光缆的状态（如“空闲→占用”），导致数据不一致。问题： 如何通过Seata的AT模式解决此问题？请描述分支事务注册和全局锁机制的作用。 如果因网络波动导致Seata TC协调失败，如何结合RabbitMQ的消息重试保证最终一致性？ 考察点：分布式事务边界划分、异常处理与补偿机制设计。 场景2：突发流量下的系统保护背景：某次资源查询接口因促销活动流量突增10倍，Redis缓存击穿导致数据库负载飙升。问题： 如何通过Redis+Lua脚本实现分布式锁控制热点Key的重建？ 若缓存集群全部宕机，如何通过Sentinel的熔断降级策略避免数据库崩溃？ 考察点：高并发场景下的缓存设计、熔断策略与容灾意识。 场景3：分库分表后的数据迁移背景：历史资源表按月分片后，需将旧数据迁移到新分片策略（如从按时间分片改为按区域+时间分片）。问题： 如何设计数据迁移方案保证业务无感知？是否需要停机？ 迁移过程中如何处理新旧数据的双写一致性？ 考察点：分库分表迁移经验、数据一致性保障手段（如影子表、Binlog同步）。 场景4：跨团队协作冲突背景：前端团队要求后端在资源查询接口中新增一个字段，但该字段需关联5张表且计算耗时，可能影响接口性能。问题： 如何与前端沟通平衡需求与性能？ 若必须实现，如何通过缓存预计算或异步加载优化响应时间？ 考察点：技术方案权衡能力、沟通技巧与性能优化思路。 场景5：线上故障排查（结合简历中的性能优化案例）背景：某天监控显示资源查询接口响应时间从150ms突增至3s，但Redis和数据库指标正常。问题： 可能的故障点有哪些？如何通过Arthas或日志快速定位？ 如果发现是Elasticsearch聚合查询变慢，如何优化分片策略或查询语句？ 考察点：全链路监控意识、故障排查方法论与工具使用熟练度。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"多线程面试题","slug":"skills/interview/interview3","date":"2025-04-07T07:20:48.000Z","updated":"2025-04-07T07:20:48.000Z","comments":true,"path":"2025/04/07/skills/interview/interview3/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/07/skills/interview/interview3/","excerpt":"","text":"一、基础知识 什么是线程？线程和进程的区别是什么？ 线程是程序执行流的最小单位，一个进程可以包含多个线程。 区别： 进程是资源分配的基本单位，线程是 CPU 调度的基本单位。 线程共享进程的内存空间，而进程有独立的内存空间。 线程间通信更容易，进程间通信需要 IPC（如管道、消息队列等）。 Java 中如何创建线程？有几种方式？分别有什么优缺点？ 方式： 继承 Thread 类并重写 run() 方法。 12Thread t = new Thread(() -&gt; System.out.println(&quot;Thread running&quot;));t.start(); 优点：简单直接；缺点：由于 Java 不支持多继承，限制了类的扩展性。 实现 Runnable 接口。 12Runnable task = () -&gt; System.out.println(&quot;Runnable task&quot;);new Thread(task).start(); 优点：更灵活，支持多继承；缺点：无返回值和异常处理能力。 使用 Callable 和 Future。 1234ExecutorService executor = Executors.newSingleThreadExecutor();Future&lt;Integer&gt; result = executor.submit(() -&gt; 42);System.out.println(result.get());executor.shutdown(); 优点：支持返回值和异常处理；缺点：依赖线程池。 start() 方法和 run() 方法的区别是什么？ start() 启动新线程并调用 run() 方法，而直接调用 run() 只是在当前线程中执行方法，不会启动新线程。 线程的生命周期有哪些状态？请详细描述每个状态及其转换条件。 状态： New：线程被创建但尚未启动。 Runnable：线程已启动，正在等待 CPU 时间片。 Blocked&#x2F;Waiting：线程因等待锁或资源而阻塞。 Timed Waiting：线程处于等待状态，但设置了超时时间。 Terminated：线程执行完毕或被终止。 什么是守护线程（Daemon Thread）？如何设置守护线程？ 守护线程是为其他线程提供服务的线程，当所有用户线程结束时，守护线程自动终止。 设置方法：thread.setDaemon(true); 如何获取当前线程的引用？如何获取主线程的引用？ 获取当前线程：Thread.currentThread(); 获取主线程：通过 Thread.currentThread() 在主线程中调用即可。 二、线程同步与并发控制 什么是线程安全？什么情况下会出现线程安全问题？ 线程安全是指多个线程访问共享资源时，程序能正确运行而不出现数据不一致的情况。 常见问题：竞态条件、死锁、活锁、饥饿。 Java 中有哪些实现线程同步的方式？ synchronized 关键字：修饰方法或代码块，保证同一时刻只有一个线程访问。 ReentrantLock：显式锁，支持公平锁、可中断锁等高级功能。 ReadWriteLock：允许多个读线程同时访问，但写线程独占。 synchronized 的锁机制是如何工作的？它有哪些使用场景？ 工作原理：基于对象头的 Monitor 锁机制，确保同一时刻只有一个线程持有锁。 场景：保护共享资源的访问，如计数器、缓存。 synchronized 和 ReentrantLock 的区别是什么？在什么情况下选择使用它们？ 区别： synchronized 是隐式锁，语法简单；ReentrantLock 是显式锁，功能强大。 ReentrantLock 支持公平锁、可中断锁、尝试锁等特性。 选择：优先使用 synchronized，除非需要 ReentrantLock 的高级功能。 什么是死锁？如何避免死锁？ 死锁：多个线程互相等待对方释放资源，导致无法继续执行。 避免方法： 按固定顺序获取锁。 使用超时机制（如 tryLock）。 避免嵌套锁。 什么是线程间的通信？如何实现线程间的通信？ 线程间通信：通过共享变量或消息传递协调线程行为。 实现方式： wait()、notify() 和 notifyAll()。 Condition 接口。 什么是活锁和饥饿？它们与死锁有什么区别？ 活锁：线程不断尝试操作，但始终失败。 饥饿：某些线程长期得不到资源。 区别：死锁是线程互相等待，活锁是线程不断尝试，饥饿是资源分配不均。 三、高级并发工具 Java 并发包（java.util.concurrent）提供了哪些核心工具类？ 线程池：ExecutorService、ThreadPoolExecutor。 同步工具：CountDownLatch、CyclicBarrier、Semaphore。 并发集合：ConcurrentHashMap、CopyOnWriteArrayList。 如何使用线程池？线程池有哪些核心参数？如何配置一个合适的线程池？ 核心参数： 核心线程数（corePoolSize） 最大线程数（maximumPoolSize） 队列容量（workQueue） 空闲线程存活时间（keepAliveTime） 配置：根据任务类型（CPU 密集型、IO 密集型）调整线程数。 Future 和 CompletableFuture 的区别是什么？如何使用它们处理异步任务？ Future：只支持简单的异步结果获取。 CompletableFuture：支持链式调用和组合操作。 示例： 123CompletableFuture.supplyAsync(() -&gt; &quot;Hello&quot;) .thenApply(s -&gt; s + &quot; World&quot;) .thenAccept(System.out::println); 什么是 Fork&#x2F;Join 框架？它的适用场景是什么？ 适用场景：递归分治问题，如排序、搜索。 Atomic 类的作用是什么？常见的 Atomic 类有哪些？ 提供原子操作，避免锁开销。 常见类：AtomicInteger、AtomicLong、AtomicReference。 ConcurrentHashMap 和普通 HashMap 的区别是什么？它是如何实现线程安全的？ 区别：ConcurrentHashMap 支持并发访问，而 HashMap 不支持。 实现：分段锁（Segment Lock）或 CAS 操作。 CopyOnWriteArrayList 是什么？它的适用场景和缺点是什么？ 场景：读多写少的场景。 缺点：写操作代价高，占用更多内存。 四、并发编程中的常见问题 什么是可见性、原子性和有序性？如何保证它们？ 可见性：通过 volatile 或锁保证。 原子性：通过 synchronized 或 Atomic 类保证。 有序性：通过 volatile 或 happens-before 规则保证。 volatile 关键字的作用是什么？它能解决哪些问题？ 作用：保证变量的可见性和禁止指令重排序。 解决问题：避免多线程环境下变量不可见或重排序导致的问题。 双重检查锁定（Double-Checked Locking）是什么？为什么需要使用 volatile 修饰单例对象？ 防止指令重排序导致的半初始化问题。 什么是伪共享（False Sharing）？如何避免伪共享？ 避免方法：通过填充字节（Padding）让变量分布在不同缓存行。 如何优雅地停止一个线程？有哪些方法可以实现？ 方法： 使用标志位。 使用 interrupt() 方法。 线程中断的三种方式是什么？如何正确处理中断？ 方式： 调用 interrupt()。 检查 isInterrupted()。 捕获 InterruptedException。 五、实际应用场景 如何设计一个生产者-消费者模型？有哪些实现方式？ 实现：使用 BlockingQueue 或 synchronized + wait/notify。 如何实现一个线程安全的单例模式？有哪些方法？ 方法： 饿汉式。 懒汉式 + synchronized。 双重检查锁定 + volatile。 静态内部类。 枚举。 （剩余问题的答案略，可以根据需要继续补充。）","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程池","slug":"线程池","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"面试题","slug":"skills/interview/interview5","date":"2025-04-07T07:20:48.000Z","updated":"2025-04-07T07:20:48.000Z","comments":true,"path":"2025/04/07/skills/interview/interview5/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/07/skills/interview/interview5/","excerpt":"","text":"一、Spring Boot自动配置的核心过程： 启动触发：通过@EnableAutoConfiguration启用自动配置。 加载配置类：从META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports读取候选配置类。 条件过滤：基于@Conditional系列注解（如@ConditionalOnClass、@ConditionalOnMissingBean）筛选有效配置。 应用配置：按优先级顺序实例化符合条件的Bean，完成自动装配。 整个过程遵循”约定优于配置”，减少手动设置，提升开发效率。 二、springboot打包成war的方式将Spring Boot项目打包为WAR只需两步： 修改pom.xml将打包方式改为war并添加provided范围的Tomcat依赖； 让主类继承SpringBootServletInitializer并重写configure方法**。最后用mvn package命令生成WAR文件即可部署到外部容器。 三、springboot的核心注解 @SpringBootApplication：组合了@Configuration、@EnableAutoConfiguration和@ComponentScan三个注解，用于启动一个Spring Boot应用。 四、springboot的全局异常处理Spring Boot 全局异常处理的核心实现方式： @ControllerAdvice + @ExceptionHandler定义全局异常处理类，用 @ControllerAdvice 标注，内部方法用 @ExceptionHandler 捕获特定异常。 返回统一结构在处理方法中封装统一的错误响应（如错误码、错误信息）。 覆盖默认异常处理可覆盖 Spring Boot 默认的 /error 处理，实现自定义异常页面或 JSON 响应。 示例代码： 123456789101112131415161718192021@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(Exception.class) public ResponseEntity&lt;ErrorResponse&gt; handleException(Exception e) &#123; return ResponseEntity .status(500) .body(new ErrorResponse(500, e.getMessage())); &#125;&#125;``` 特点：**简单注解驱动**，**统一异常拦截**，**支持 REST 和页面**。## 五、在 Spring Boot 中获取配置文件（`application.yml` 或 `application.properties`）中的配置有以下几种常用方式：---### 1. **`@Value` 注解直接注入**```java@Value(&quot;$&#123;配置键名&#125;&quot;)private String configValue; 示例：配置文件： 1app.name=MyApp 代码获取： 12@Value(&quot;$&#123;app.name&#125;&quot;)private String appName; 2. @ConfigurationProperties 绑定到对象适合分组获取多个配置项。步骤： 定义配置类：1234567@ConfigurationProperties(prefix = &quot;app&quot;) // 指定配置前缀@Component // 或通过@EnableConfigurationProperties启用public class AppConfig &#123; private String name; private int version; // getter/setter&#125; 配置文件：123app: name: MyApp version: 1 直接注入使用：12@Autowiredprivate AppConfig appConfig; 3. 通过 Environment 对象动态获取1234@Autowiredprivate Environment env;String value = env.getProperty(&quot;配置键名&quot;); 4. @PropertySource 读取自定义配置文件123456@Configuration@PropertySource(&quot;classpath:custom.properties&quot;)public class CustomConfig &#123; @Value(&quot;$&#123;custom.key&#125;&quot;) private String customValue;&#125; 注意事项： 优先级：Spring Boot 配置加载顺序为：命令行参数 &gt; application-&#123;profile&#125;.yml &gt; application.yml &gt; 默认值。 多环境配置：使用 spring.profiles.active=dev 指定环境（如 application-dev.yml）。 类型安全：推荐使用 @ConfigurationProperties 避免硬编码和类型错误。 选择方式根据场景： 简单值 → @Value 分组配置 → @ConfigurationProperties 动态获取 → Environment 六、Spring Boot 加载 所有类型配置文件 的顺序（优先级从高到低）：1. 外部配置（优先级最高） 命令行参数（--key=value，如 java -jar app.jar --server.port=8081） 操作系统环境变量（如 export SERVER_PORT=8081） Java 系统属性（-Dkey=value，如 -Dserver.port=8081） 2. 外部配置文件 config/ 目录下的配置文件（按以下顺序）： 项目根目录下的 /config/application.&#123;properties|yml&#125; 项目根目录下的 application.&#123;properties|yml&#125; classpath:/config/application.&#123;properties|yml&#125;（resources/config/） classpath:/application.&#123;properties|yml&#125;（resources/） 3. Profile 专属配置 **application-&#123;profile&#125;.&#123;properties|yml&#125;**（如 application-dev.yml） 通过 spring.profiles.active 指定生效的 Profile（如 dev、prod） 4. 默认配置（优先级最低） @PropertySource 指定的自定义文件（如 @PropertySource(&quot;classpath:custom.properties&quot;)） Spring Boot 默认配置（如 SpringApplication.setDefaultProperties） 总结（加载顺序）： 命令行参数 &gt; 环境变量 &gt; Java 系统属性 外部 /config/ 目录配置 &gt; 外部根目录配置 &gt; classpath:/config/ &gt; classpath:/ **application-&#123;profile&#125;.&#123;properties|yml&#125;**（Profile 专属配置） @PropertySource 自定义文件 &gt; Spring Boot 默认值 关键点： 相同配置，后加载的会覆盖先加载的。 Profile 机制允许不同环境使用不同配置（如 dev、test、prod）。 外部配置优先级 &gt; JAR 包内部配置，便于部署时动态调整。 适用于：properties、yml、yaml 等所有 Spring Boot 支持的配置文件格式。 七、在 Spring Boot（特别是结合 Spring Cloud 时），**bootstrap 配置文件**的加载逻辑如下： 优先级最高：比 application 文件更早加载，用于系统级配置（如加密信息、Consul&#x2F;Nacos 配置中心连接参数）。 加载顺序： 先加载 bootstrap.yml/properties（或 bootstrap-&#123;profile&#125;.yml） 再加载 application.yml/properties 典型场景：配置中心的地址、加密密钥、Spring Cloud 相关配置（如 spring.cloud.nacos.config）。 默认关闭：需依赖 spring-cloud-starter-bootstrap（旧版）或通过 spring.config.use-legacy-processing=true 启用（新版 Spring Cloud 2020+）。 一句话：bootstrap 是“配置的配置”，先于 application 加载，适合初始化关键基础设施。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Mysql如何优化慢SQL","slug":"skills/mysql/sqlBeBetterInMysql","date":"2025-04-07T07:20:48.000Z","updated":"2025-04-07T07:20:48.000Z","comments":true,"path":"2025/04/07/skills/mysql/sqlBeBetterInMysql/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/07/skills/mysql/sqlBeBetterInMysql/","excerpt":"","text":"在 MySQL 中，针对慢 SQL 的优化是一个常见的性能调优任务。慢 SQL 通常是由于查询效率低下、索引缺失、数据量过大或数据库设计不合理等原因引起的。以下是优化慢 SQL 的详细步骤和方法： 1. 定位慢 SQL(1) 开启慢查询日志MySQL 提供了慢查询日志功能，可以记录执行时间超过指定阈值的 SQL 语句。 配置参数：1234567891011-- 查看当前慢查询日志是否开启SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;-- 设置慢查询日志路径SET GLOBAL slow_query_log_file = &#x27;/path/to/slow_query.log&#x27;;-- 设置慢查询时间阈值（单位：秒）SET GLOBAL long_query_time = 1;-- 开启慢查询日志SET GLOBAL slow_query_log = &#x27;ON&#x27;; 慢查询日志会记录执行时间超过 long_query_time 的 SQL。 (2) 使用 EXPLAIN 分析查询计划通过 EXPLAIN 命令可以查看 SQL 的执行计划，分析查询是否使用了索引以及扫描了多少行数据。 1EXPLAIN SELECT * FROM table_name WHERE column_name = &#x27;value&#x27;; 重点关注以下字段： type：查询类型（如 ALL 表示全表扫描，index 表示索引扫描，ref 表示使用索引查找）。 rows：扫描的行数，越小越好。 Extra：额外信息（如 Using where、Using filesort、Using temporary 等，可能表明性能问题）。 2. 优化 SQL 查询(1) 使用合适的索引 创建索引： 在经常用于过滤（WHERE）、排序（ORDER BY）或连接（JOIN）的列上创建索引。 示例：1CREATE INDEX idx_column_name ON table_name(column_name); 复合索引： 如果查询涉及多个条件，可以创建复合索引（联合索引），但要注意索引列的顺序。 示例：1CREATE INDEX idx_col1_col2 ON table_name(col1, col2); (2) 避免全表扫描 减少不必要的列： 只查询需要的列，避免使用 SELECT *。 示例：1SELECT col1, col2 FROM table_name WHERE condition; 限制返回行数： 使用 LIMIT 限制返回的行数，尤其是分页查询时。 示例：1SELECT * FROM table_name WHERE condition LIMIT 10; (3) 优化 JOIN 操作 确保连接列有索引： 在 JOIN 操作中，确保连接条件的列上有索引。 避免笛卡尔积： 确保 JOIN 条件明确，避免无条件连接导致的笛卡尔积。 (4) 避免复杂的子查询 改写子查询为 JOIN： 子查询可能会导致性能问题，尽量将其改写为 JOIN。 示例：12345678-- 原始子查询SELECT * FROM table1 WHERE id IN (SELECT id FROM table2 WHERE condition);-- 改写为 JOINSELECT table1.* FROM table1 JOIN table2 ON table1.id = table2.id WHERE table2.condition; (5) 使用覆盖索引 覆盖索引是指查询的所有列都包含在索引中，从而避免回表操作。 示例：12-- 假设有一个复合索引 (col1, col2)SELECT col1, col2 FROM table_name WHERE col1 = &#x27;value&#x27;; 3. 数据库层面优化(1) 调整 MySQL 配置 调整缓冲区大小： 增加 innodb_buffer_pool_size，提升 InnoDB 表的查询性能。 示例：1SET GLOBAL innodb_buffer_pool_size = 4G; 优化查询缓存（MySQL 8.0 已移除）： 如果使用的是 MySQL 5.x 版本，可以启用查询缓存。 示例：12SET GLOBAL query_cache_type = 1;SET GLOBAL query_cache_size = 64M; (2) 分区表 对于大表，可以使用分区表来提高查询效率。 示例：1234567CREATE TABLE partitioned_table ( id INT, created_at DATE) PARTITION BY RANGE (YEAR(created_at)) ( PARTITION p2020 VALUES LESS THAN (2021), PARTITION p2021 VALUES LESS THAN (2022)); (3) 数据归档 将历史数据迁移到归档表中，减少主表的数据量。 4. 应用层面优化(1) 缓存查询结果 使用应用层缓存（如 Redis、Memcached）存储频繁查询的结果，减少数据库压力。 (2) 异步处理 对于耗时的查询或写操作，可以采用异步方式处理，避免阻塞主线程。 (3) 批量操作 对于大量数据的插入或更新操作，尽量采用批量处理，减少单条语句的开销。 5. 监控与测试(1) 使用性能监控工具 使用工具（如 MySQL 自带的 Performance Schema 或第三方工具如 pt-query-digest）分析慢查询。 示例：1SELECT * FROM performance_schema.events_statements_summary_by_digest; (2) 测试优化效果 使用 EXPLAIN 和 SHOW PROFILES 分析优化前后的查询性能。 示例：1SHOW PROFILES; 总结优化慢 SQL 是一个系统性工程，通常需要从以下几个方面入手： 定位问题：通过慢查询日志和 EXPLAIN 找到瓶颈。 优化查询：合理使用索引、避免全表扫描、改写复杂查询。 调整配置：优化 MySQL 参数和表结构。 应用优化：引入缓存、异步处理等手段减轻数据库压力。 通过以上方法，可以有效提升慢 SQL 的执行效率，改善数据库的整体性能。如果仍有具体问题，请提供 SQL 和表结构，我可以进一步分析！","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/MySql/"}]},{"title":"多线程开发","slug":"skills/interview/interview2","date":"2025-04-07T07:10:13.000Z","updated":"2025-04-07T07:10:13.000Z","comments":true,"path":"2025/04/07/skills/interview/interview2/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/04/07/skills/interview/interview2/","excerpt":"","text":"多线程使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package basic.multipleThread;import java.util.concurrent.*;public class ThreadPool &#123; private void makeThreadPool() &#123; // 直接启动线程的方式（不推荐） ThreadExtend threadExtend = new ThreadExtend(); threadExtend.start(); ThreadRunnable threadRunable = new ThreadRunnable(); Thread thread = new Thread(threadRunable); thread.start(); ThreadCallable threadCallable = new ThreadCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(threadCallable); try &#123; futureTask.run(); // 或者使用线程池来执行 String result = futureTask.get(); System.out.println(&quot;Callable Result: &quot; + result); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; private void createThreadPoolExamples() &#123; // 1. 使用 FixedThreadPool ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); fixedThreadPool.submit(new ThreadExtend()); fixedThreadPool.submit(new ThreadRunnable()); Future&lt;String&gt; futureFromFixedThreadPool = fixedThreadPool.submit(new ThreadCallable()); try &#123; String result = futureFromFixedThreadPool.get(5, TimeUnit.SECONDS); System.out.println(&quot;FixedThreadPool Callable Result: &quot; + result); &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; fixedThreadPool.shutdown(); &#125; // 2. 使用 CachedThreadPool ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); cachedThreadPool.submit(new ThreadExtend()); cachedThreadPool.submit(new ThreadRunnable()); Future&lt;String&gt; futureFromCachedThreadPool = cachedThreadPool.submit(new ThreadCallable()); try &#123; String result = futureFromCachedThreadPool.get(5, TimeUnit.SECONDS); System.out.println(&quot;CachedThreadPool Callable Result: &quot; + result); &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; cachedThreadPool.shutdown(); &#125; // 3. 使用 SingleThreadExecutor ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); singleThreadExecutor.submit(new ThreadExtend()); singleThreadExecutor.submit(new ThreadRunnable()); Future&lt;String&gt; futureFromSingleThreadExecutor = singleThreadExecutor.submit(new ThreadCallable()); try &#123; String result = futureFromSingleThreadExecutor.get(5, TimeUnit.SECONDS); System.out.println(&quot;SingleThreadExecutor Callable Result: &quot; + result); &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; singleThreadExecutor.shutdown(); &#125; // 4. 使用 ScheduledThreadPool ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); scheduledThreadPool.schedule(new ThreadExtend(), 1, TimeUnit.SECONDS); scheduledThreadPool.schedule(new ThreadRunnable(), 1, TimeUnit.SECONDS); ScheduledFuture&lt;String&gt; futureFromScheduledThreadPool = scheduledThreadPool.schedule(new ThreadCallable(), 1, TimeUnit.SECONDS); try &#123; String result = futureFromScheduledThreadPool.get(5, TimeUnit.SECONDS); System.out.println(&quot;ScheduledThreadPool Callable Result: &quot; + result); &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; scheduledThreadPool.shutdown(); &#125; // 5. 使用 WorkStealingPool ExecutorService workStealingPool = Executors.newWorkStealingPool(); workStealingPool.submit(new ThreadExtend()); workStealingPool.submit(new ThreadRunnable()); Future&lt;String&gt; futureFromWorkStealingPool = workStealingPool.submit(new ThreadCallable()); try &#123; String result = futureFromWorkStealingPool.get(5, TimeUnit.SECONDS); System.out.println(&quot;WorkStealingPool Callable Result: &quot; + result); &#125; catch (InterruptedException | ExecutionException | TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; workStealingPool.shutdown(); &#125; &#125; public static void main(String[] args) &#123; ThreadPool threadPool = new ThreadPool(); threadPool.makeThreadPool(); threadPool.createThreadPoolExamples(); &#125;&#125;// 示例实现：ThreadExtendclass ThreadExtend extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;ThreadExtend is running...&quot;); // 模拟任务逻辑 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;ThreadExtend was interrupted: &quot; + e.getMessage()); &#125; &#125;&#125;// 示例实现：ThreadRunnableclass ThreadRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;ThreadRunnable is running...&quot;); // 模拟任务逻辑 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.err.println(&quot;ThreadRunnable was interrupted: &quot; + e.getMessage()); &#125; &#125;&#125;// 示例实现：ThreadCallableclass ThreadCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;ThreadCallable is running...&quot;); // 模拟任务逻辑 Thread.sleep(1000); return &quot;Callable Task Completed&quot;; &#125;&#125; 优化点总结 异常处理增强：为 Future.get() 方法添加超时机制，并捕获可能的异常（如 TimeoutException 和 ExecutionException），确保程序的健壮性。 资源管理改进：在 finally 块中调用 executor.shutdown()，确保线程池在任务完成后被正确关闭。 多种线程池创建方式：展示了 FixedThreadPool、CachedThreadPool、SingleThreadExecutor、ScheduledThreadPool 和 WorkStealingPool 五种创建线程池的方式，并展示了如何使用这些线程池来提交任务。 代码封装性提升：将线程任务的启动逻辑封装到 ThreadPool 类中，提高代码的可读性和可维护性。","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程池","slug":"线程池","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"Java 并发工具：CountDownLatch 与 CyclicBarrier 详解","slug":"skills/point/countdownlatchAndCycleBarrier","date":"2025-01-08T06:10:11.000Z","updated":"2025-01-08T06:10:11.000Z","comments":true,"path":"2025/01/08/skills/point/countdownlatchAndCycleBarrier/","permalink":"https://daiyafeigithub.github.io/simonzzz/2025/01/08/skills/point/countdownlatchAndCycleBarrier/","excerpt":"","text":"Java 并发工具：CountDownLatch 与 CyclicBarrier 详解在多线程编程中，协调多个线程的执行顺序是一个常见的需求。CountDownLatch 和 CyclicBarrier 是 Java 并发包 java.util.concurrent 提供的两个同步工具类，它们可以帮助我们轻松实现线程间的协作。本文将通过实际例子详细讲解两者的原理、区别以及适用场景。 一、CountDownLatch 讲解1. CountDownLatch 的核心概念CountDownLatch 是一个同步工具类，允许一个或多个线程等待其他线程完成一系列操作后继续执行。它的核心是基于一个计数器： 初始值为指定的计数值（count）。 每次调用 countDown() 方法时，计数器减 1。 当计数器减到 0 时，所有等待的线程会被唤醒并继续执行。 特点： 计数器不可重置，只能使用一次。 主要用于“一个线程等待多个线程完成任务”的场景。 2. CountDownLatch 的典型应用场景假设我们有一个物流系统，主线程需要等待三个仓库分别完成货物准备后才能启动运输任务。这种场景非常适合使用 CountDownLatch。 3. 示例代码以下是一个完整的 CountDownLatch 使用示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.CountDownLatch;public class LogisticsSystemWithCountDownLatch &#123; public static void main(String[] args) &#123; // 创建一个 CountDownLatch，初始计数为 3（代表 3 个仓库） CountDownLatch latch = new CountDownLatch(3); // 启动 3 个仓库线程 for (int i = 1; i &lt;= 3; i++) &#123; new Thread(new WarehouseTask(i, latch)).start(); &#125; try &#123; // 主线程等待所有仓库完成任务 latch.await(); System.out.println(&quot;所有仓库货物已准备完毕，开始运输！&quot;); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.out.println(&quot;主线程被中断: &quot; + e.getMessage()); &#125; &#125; // 仓库任务类 static class WarehouseTask implements Runnable &#123; private final int warehouseId; private final CountDownLatch latch; public WarehouseTask(int warehouseId, CountDownLatch latch) &#123; this.warehouseId = warehouseId; this.latch = latch; &#125; @Override public void run() &#123; try &#123; System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 正在准备货物...&quot;); Thread.sleep((long) (Math.random() * 2000)); // 模拟准备时间 System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 已完成货物准备！&quot;); latch.countDown(); // 完成任务，计数器减 1 &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 发生异常: &quot; + e.getMessage()); &#125; &#125; &#125;&#125; 4. 输出示例运行上述代码后，可能得到如下输出（随机时间导致每次结果略有不同）： 1234567仓库 1 正在准备货物...仓库 2 正在准备货物...仓库 3 正在准备货物...仓库 3 已完成货物准备！仓库 1 已完成货物准备！仓库 2 已完成货物准备！所有仓库货物已准备完毕，开始运输！ 5. 核心方法 **await()**：让当前线程等待，直到计数器减到 0。 **countDown()**：将计数器减 1。 不可重置：一旦计数器减到 0，无法再次使用。 二、CyclicBarrier 讲解1. CyclicBarrier 的核心概念CyclicBarrier 是一个同步工具类，允许多个线程相互等待，直到所有线程都到达某个屏障点后再继续执行。它的核心是基于一个计数器： 初始值为参与线程的数量（parties）。 每次调用 await() 方法时，计数器减 1。 当计数器减到 0 时，所有等待的线程会被唤醒并继续执行。 特点： 计数器可以重置，支持多次同步。 可以设置屏障动作（Runnable），当所有线程到达屏障点时执行特定逻辑。 2. CyclicBarrier 的典型应用场景假设我们有一个物流系统，多个仓库需要同时完成货物装车后才能统一发车。这种场景非常适合使用 CyclicBarrier。 3. 示例代码以下是一个完整的 CyclicBarrier 使用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class LogisticsSystemWithCyclicBarrier &#123; // 定义仓库数量 private static final int WAREHOUSE_COUNT = 3; public static void main(String[] args) &#123; // 创建一个 CyclicBarrier，指定参与线程数，并设置屏障动作 CyclicBarrier cyclicBarrier = new CyclicBarrier(WAREHOUSE_COUNT, () -&gt; &#123; System.out.println(&quot;所有仓库货物已装车，开始统一发车！&quot;); &#125;); // 启动每个仓库的线程 for (int i = 1; i &lt;= WAREHOUSE_COUNT; i++) &#123; new Thread(new WarehouseTask(i, cyclicBarrier)).start(); &#125; &#125; // 仓库任务类 static class WarehouseTask implements Runnable &#123; private final int warehouseId; private final CyclicBarrier cyclicBarrier; public WarehouseTask(int warehouseId, CyclicBarrier cyclicBarrier) &#123; this.warehouseId = warehouseId; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; // 1. 准备货物 System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 正在准备货物...&quot;); Thread.sleep((long) (Math.random() * 2000)); // 模拟准备时间 // 2. 装车 System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 正在装车...&quot;); Thread.sleep((long) (Math.random() * 2000)); // 模拟装车时间 // 到达屏障点，等待其他仓库 System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 已完成装车，等待其他仓库...&quot;); cyclicBarrier.await(); // 3. 发车（屏障动作完成后，所有线程继续执行） System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 的货物已发车！&quot;); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; Thread.currentThread().interrupt(); System.out.println(&quot;仓库 &quot; + warehouseId + &quot; 发生异常: &quot; + e.getMessage()); &#125; &#125; &#125;&#125; 4. 输出示例运行上述代码后，可能得到如下输出： 12345678910111213仓库 1 正在准备货物...仓库 2 正在准备货物...仓库 3 正在准备货物...仓库 1 正在装车...仓库 3 正在装车...仓库 2 正在装车...仓库 1 已完成装车，等待其他仓库...仓库 2 已完成装车，等待其他仓库...仓库 3 已完成装车，等待其他仓库...所有仓库货物已装车，开始统一发车！仓库 1 的货物已发车！仓库 2 的货物已发车！仓库 3 的货物已发车！ 5. 核心方法 **await()**：让当前线程等待，直到所有线程都到达屏障点。 屏障动作：可以在构造函数中传入一个 Runnable，当所有线程到达屏障点时执行。 可重置：计数器可以重新设置，支持多次同步。 三、CountDownLatch 与 CyclicBarrier 的对比 特性 CountDownLatch CyclicBarrier 计数器重置 不可重置，只能使用一次 可以重置，支持多次同步 线程角色 一个或多个线程等待其他线程完成任务 多个线程相互等待，直到所有线程都到达屏障点 屏障动作 不支持 支持在所有线程到达屏障点后执行一个屏障动作 典型应用场景 等待某些任务完成后才能继续执行 需要多个线程协同完成任务后再继续执行 实现方式 基于 AQS（AbstractQueuedSynchronizer）实现 基于 ReentrantLock 和 Condition 实现 四、总结 CountDownLatch 更适合“一个线程等待多个线程完成任务”的场景，例如主线程等待子线程完成初始化、任务分配等。 CyclicBarrier 更适合“多个线程相互等待，直到所有线程都完成任务后再继续执行”的场景，例如多仓库协同工作、批量数据处理等。 通过本文的讲解和示例代码，相信你已经掌握了 CountDownLatch 和 CyclicBarrier 的使用方法及其适用场景。希望这些内容能帮助你在并发编程中更加得心应手！","categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"教程","slug":"教程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%95%99%E7%A8%8B/"},{"name":"cycleBarrier","slug":"cycleBarrier","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/cycleBarrier/"},{"name":"countDownLatch","slug":"countDownLatch","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/countDownLatch/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%8A%80%E6%9C%AF/"},{"name":"旅游","slug":"旅游","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E6%97%85%E6%B8%B8/"},{"name":"软考","slug":"软考","permalink":"https://daiyafeigithub.github.io/simonzzz/categories/%E8%BD%AF%E8%80%83/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/RabbitMQ/"},{"name":"Java","slug":"Java","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程池","slug":"线程池","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"AI","slug":"AI","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/AI/"},{"name":"Python","slug":"Python","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/Python/"},{"name":"旅游","slug":"旅游","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%97%85%E6%B8%B8/"},{"name":"技术","slug":"技术","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%8A%80%E6%9C%AF/"},{"name":"教程","slug":"教程","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E6%95%99%E7%A8%8B/"},{"name":"deepseek","slug":"deepseek","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/deepseek/"},{"name":"软考","slug":"软考","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E8%BD%AF%E8%80%83/"},{"name":"中级软考","slug":"中级软考","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E4%B8%AD%E7%BA%A7%E8%BD%AF%E8%80%83/"},{"name":"mysql","slug":"mysql","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/mysql/"},{"name":"面试","slug":"面试","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySql","slug":"MySql","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/MySql/"},{"name":"cycleBarrier","slug":"cycleBarrier","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/cycleBarrier/"},{"name":"countDownLatch","slug":"countDownLatch","permalink":"https://daiyafeigithub.github.io/simonzzz/tags/countDownLatch/"}]}